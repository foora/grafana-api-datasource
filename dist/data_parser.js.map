{"version":3,"sources":["data_parser.js"],"names":["Parser","ConfigStr","options","JSON","parse","err","res","data","format","parseTableData","parseSeriesData","Array","length","columns","result","type","rows","j","clen","key","label","push","text","i","len","item","lines","timeKey","line","temp","target","datapoints","forEach"],"mappings":"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","file":"data_parser.js","sourcesContent":["export class Parser {\n    parseQueryConfig(ConfigStr) {\n        let options;\n        try {\n            options = JSON.parse(ConfigStr);\n        } catch (err) {\n            options = {};\n        }\n        return options;\n    }\n    parseQueryResponse(res, options) {\n        if (!res.data) {\n            return { data: [] };\n        }\n\n        let format = options.format;\n\n        if (format === 'table') {\n            return this.parseTableData(res.data, options);\n        } else if (format === 'series') {\n            return this.parseSeriesData(res.data, options);\n        } else {\n            return { data: [] };\n        }\n    }\n\n    parseTableData(data, options) {\n        if (!(data instanceof Array) || data.length === 0) {\n            return { data: [] };\n        }\n        let columns = options.columns;\n        if (!(columns instanceof Array) || columns.length === 0) {\n            return { data: [] };\n        }\n        let result = {\n            type: 'table',\n            columns: [],\n            rows: []\n        };\n        for (let j = 0, clen = columns.length; j < clen; j++) {\n            let key = columns[j].key;\n            let label = columns[j].label;\n            result.columns.push({ text: label });\n            for (let i = 0, len = data.length; i < len; i++) {\n                if (!result.rows[i]) result.rows[i] = [];\n                let item = data[i];\n                result.rows[i].push(item[key]);\n            }\n        }\n        return { data: [result] };\n    }\n    parseSeriesData(data, options) {\n        if (!(data instanceof Array) || data.length === 0) {\n            return { data: [] };\n        }\n        let lines = options.lines;\n        if (!lines || !lines.timeKey || !(lines.line instanceof Array) || lines.line.length === 0) {\n            return { data: [] };\n        }\n        let timeKey = lines.timeKey;\n        let result = [];\n        for (let i = 0, len = lines.line.length; i < len; i++) {\n            let temp = {\n                target: lines.line[i].label,\n                datapoints: []\n            };\n            let key = lines.line[i].key;\n            data.forEach((item) => temp.datapoints.push([item[key], item[timeKey]]));\n            result.push(temp);\n        }\n        return { data: result };\n    }\n}"]}